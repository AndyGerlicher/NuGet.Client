// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using NuGet.Common;
using NuGet.Frameworks;
using NuGet.LibraryModel;
using NuGet.ProjectModel;
using NuGet.Shared;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;

namespace NuGet.Commands
{
    internal class TransitiveNoWarnUtils
    {
        // static should be fine across multiple restore calls as this solely depends on the csproj file of the project.
        private static readonly ConcurrentDictionary<string, WarningPropertiesCollection> _warningPropertiesCache = 
            new ConcurrentDictionary<string, WarningPropertiesCollection>();

        /// <summary>
        /// Creates a PackageSpecificWarningProperties for a project generated by traversing the dependency graph.
        /// </summary>
        /// <param name="dgSpec">Restore DGSpec containing the complete closure.</param>
        /// <param name="targetGraphs">Parent project restore target graphs.</param>
        /// <param name="parentProject">LibraryIdentity of the parent project.</param>
        /// <returns></returns>
        internal static PackageSpecificWarningProperties CreateTransitiveWarningPropertiesCollection(
            DependencyGraphSpec dgSpec,
            IEnumerable<RestoreTargetGraph> targetGraphs,
            PackageSpec parentProjectSpec)
        {
            var transitiveNoWarnProperties = new PackageSpecificWarningProperties();

            var parentWarningProperties = GetNodeWarningProperties(parentProjectSpec);

            foreach (var targetGraph in targetGraphs)
            {
                if (string.IsNullOrEmpty(targetGraph.RuntimeIdentifier))
                {
                    var transitiveNoWarnFromTargetGraph = ExtractTransitiveNoWarnProperties(
                        targetGraph, 
                        dgSpec,
                        parentProjectSpec, 
                        parentWarningProperties);

                    transitiveNoWarnProperties = MergePackageSpecificWarningProperties(
                        transitiveNoWarnProperties, 
                        transitiveNoWarnFromTargetGraph);
                }
            }

            return transitiveNoWarnProperties;
        }

        /// <summary>
        /// Traverses a Dependency grpah starting from the parent project in BF style.
        /// </summary>
        /// <param name="targetGraph">Parent project restore target graph.</param>
        /// <param name="dgSpec">Restore DGSpec containing the complete closure.</param>
        /// <param name="parentProjectSpec">PackageSpec of the parent project.</param>
        /// <param name="parentWarningPropertiesCollection">WarningPropertiesCollection of the parent project.</param>
        /// <returns>PackageSpecificWarningProperties containing all the NoWarn's for each package seen in the graph accumulated while traversing the graph.</returns>
        private static PackageSpecificWarningProperties ExtractTransitiveNoWarnProperties(
            RestoreTargetGraph targetGraph,
            DependencyGraphSpec dgSpec,
            PackageSpec parentProjectSpec,            
            WarningPropertiesCollection parentWarningPropertiesCollection)
        {
            var paths = new Dictionary<string, IEnumerable<LibraryIdentity>>();
            var dependencyMapping = new Dictionary<string, IEnumerable<LibraryDependency>>();
            var queue = new Queue<DependencyNode>();
            var seen = new HashSet<DependencyNode>();
            var frameworkReducer = new FrameworkReducer();
            var resultWarningProperties = new PackageSpecificWarningProperties();

            // All the packages in parent project's closure. 
            // Once we have collected data for all of these, we can exit.
            var parentPackageDependencies = new HashSet<string>(
                targetGraph.Flattened.Where(d => d.Key.Type == LibraryType.Package).Select(d => d.Key.Name));

            var parentTargetFramework = targetGraph.Framework;

            // Add all dependencies into a dict for a quick transitive lookup
            foreach (var dependency in targetGraph.Flattened.OrderBy(d => d.Key.Name))
            {
                // Use the full path for projects and id for packages
                var name = string.IsNullOrEmpty(dependency.Data.Match.Path) ?
                    dependency.Key.Name :
                    dependency.Data.Match.Path;

                dependencyMapping[name.ToLower()] = dependency.Data.Dependencies;
            }

            var parentDependencies = GetDirectDependencies(parentProjectSpec, parentWarningPropertiesCollection, parentTargetFramework);

            // Seed the queue with the parent project's direct dependencies
            parentDependencies.OrderBy(d => d.Id).ForEach(d => queue.Enqueue(d));

            // Add the parent project to the seen set to prevent adding it back to the queue
            seen.Add(new DependencyNode(id: parentProjectSpec.RestoreMetadata.ProjectPath.ToLowerInvariant(),
                isProject: true,
                warningPropertiesCollection: parentWarningPropertiesCollection));

            // start taking one node from the queue and get all of it's dependencies
            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                if (!seen.Contains(node))
                {
                    
                    var nodeId = node.Id;
                    var nodeIsProject = node.IsProject;
                    var nodeDependencies = dependencyMapping[nodeId];
                    var pathWarningProperties = node.WarningPropertiesCollection;

                    // If the node is a project then we need to extract the warning properties and 
                    // add those to the warning properties of the current path.
                    if (nodeIsProject)
                    {
                        // Get the node PackageSpec
                        var nodeProjectSpec = GetNodePackageSpec(dgSpec, nodeId);
                        var nodeTargetFrameworks = nodeProjectSpec.TargetFrameworks.Select(tfi => tfi.FrameworkName);

                        var nearestFramework = frameworkReducer.GetNearest(parentTargetFramework, nodeTargetFrameworks);

                        // Get the WarningPropertiesCollection from the PackageSpec
                        var nodeWarningProperties = GetNodeWarningProperties(nodeProjectSpec, nearestFramework);

                        // Merge the WarningPropertiesCollection to the one in the path
                        var mergedWarningPropertiesCollection = MergeWarningPropertiesCollection(pathWarningProperties,
                            nodeWarningProperties);

                        // Add all the project's dependencies to the Queue with the merged WarningPropertiesCollection
                        foreach (var dependency in dependencyMapping[nodeId].OrderBy(d => d.Name))
                        {
                            var queueNode = new DependencyNode(dependency.Name.ToLowerInvariant(), IsProject(dependency.LibraryRange.TypeConstraint), mergedWarningPropertiesCollection);

                            if (!seen.Contains(queueNode))
                            {
                                // Add the metadata from the parent project here.
                                queue.Enqueue(queueNode);
                            }
                        }

                    }
                    else
                    {
                        // Evaluate the package properties for the current path
                        // Check if There was any NoWarn in the path
                        var pathNoWarnForId = ExtractPathNoWarnProperties(pathWarningProperties, nodeId);

                        if (pathNoWarnForId.Count > 0)
                        {
                            // If the path has a "NoWarn" for the package then save it to the result
                            resultWarningProperties.AddRange(pathNoWarnForId.AsList(), nodeId, parentTargetFramework);
                        }
                        else
                        {
                            // If the path does not "NoWarn" for this package then remove the path from parentPackageDependencies
                            parentPackageDependencies.Remove(nodeId);

                            // If parentPackageDependencies is empty then exit the graph traversal
                            if (parentPackageDependencies.Count == 0)
                            {
                                break;
                            }
                        }
                    }
                }
            }

            return resultWarningProperties;
        }

        private static IEnumerable<DependencyNode> GetDirectDependencies(
            PackageSpec projectSpec,
            WarningPropertiesCollection warningPropertiesCollection,
            NuGetFramework targetFramework)
        {
            var dependencies = new List<DependencyNode>();

            var targetFrameworkPackageDependencies = projectSpec
                .TargetFrameworks
                .Single(tfi => tfi.FrameworkName == targetFramework)?
                .Dependencies;

            var targetFrameworkProjectDependencies = projectSpec
                .RestoreMetadata?
                .TargetFrameworks
                .Single(tfi => tfi.FrameworkName == targetFramework)?
                .ProjectReferences;

            // Unconditional package references
            foreach (var dependency in projectSpec.Dependencies.OrderBy(d => d.Name))
            {
                var queueNode = new DependencyNode(dependency.Name.ToLowerInvariant(), IsProject(dependency.LibraryRange.TypeConstraint), warningPropertiesCollection);
                dependencies.Add(queueNode);
            }

            // target framework specific package references
            if (targetFrameworkPackageDependencies != null)
            {
                foreach (var dependency in targetFrameworkPackageDependencies.OrderBy(d => d.Name))
                {
                    var queueNode = new DependencyNode(
                        id: dependency.Name.ToLowerInvariant(),
                        isProject: IsProject(dependency.LibraryRange.TypeConstraint),
                        warningPropertiesCollection: warningPropertiesCollection);

                    dependencies.Add(queueNode);
                }
            }

            // target framework specific project references
            if (targetFrameworkProjectDependencies != null)
            {
                foreach (var dependency in targetFrameworkProjectDependencies.OrderBy(d => d.ProjectPath))
                {
                    var queueNode = new DependencyNode(
                        id: dependency.ProjectPath.ToLowerInvariant(), 
                        isProject: true, 
                        warningPropertiesCollection: warningPropertiesCollection);

                    dependencies.Add(queueNode);
                }
            }

            return dependencies;
        }

        private static ISet<NuGetLogCode> ExtractPathNoWarnProperties(WarningPropertiesCollection pathWarningProperties, string id)
        {
            var result = new HashSet<NuGetLogCode>();
            if (pathWarningProperties?.ProjectWideWarningProperties?.NoWarn?.Count > 0)
            {
                result.UnionWith(pathWarningProperties.ProjectWideWarningProperties.NoWarn);
            }

            if (pathWarningProperties?.PackageSpecificWarningProperties?.Properties?.Count > 0)
            {
                foreach(var codeIdCollection in pathWarningProperties.PackageSpecificWarningProperties.Properties)
                {
                    var code = codeIdCollection.Key;
                    var IdCollection = codeIdCollection.Value;
                    if (IdCollection.ContainsKey(id))
                    {
                        result.Add(code);
                    }
                }
            }

            return result;
        }

        private static WarningPropertiesCollection GetNodeWarningProperties(PackageSpec nodeProjectSpec)
        {
            return _warningPropertiesCache.GetOrAdd(nodeProjectSpec.RestoreMetadata.ProjectPath, 
                (s) => new WarningPropertiesCollection(
                    nodeProjectSpec.RestoreMetadata?.ProjectWideWarningProperties,
                    PackageSpecificWarningProperties.CreatePackageSpecificWarningProperties(nodeProjectSpec),
                    nodeProjectSpec.TargetFrameworks.Select(f => f.FrameworkName).AsList().AsReadOnly()));
        }

        private static WarningPropertiesCollection GetNodeWarningProperties(PackageSpec nodeProjectSpec, NuGetFramework framework)
        {
            return _warningPropertiesCache.GetOrAdd(nodeProjectSpec.RestoreMetadata.ProjectPath,
                (s) => new WarningPropertiesCollection(
                    nodeProjectSpec.RestoreMetadata?.ProjectWideWarningProperties,
                    PackageSpecificWarningProperties.CreatePackageSpecificWarningProperties(nodeProjectSpec, framework),
                    nodeProjectSpec.TargetFrameworks.Select(f => f.FrameworkName).AsList().AsReadOnly()));
        }

        private static PackageSpec GetNodePackageSpec(DependencyGraphSpec dgSpec, string nodeId)
        {
            return dgSpec
                .Projects
                .Where(p => string.Equals(p.RestoreMetadata.ProjectPath, nodeId, StringComparison.OrdinalIgnoreCase))
                .First();
        }

        private static WarningPropertiesCollection MergeWarningPropertiesCollection(WarningPropertiesCollection first, 
            WarningPropertiesCollection second)
        {
            WarningPropertiesCollection result = null;

            if (TryMergeNullObjects(first, second, out object merged))
            {
                result = merged as WarningPropertiesCollection;
            }
            else
            {
                // Merge Project Wide Warning Properties
                var mergedProjectWideWarningProperties = MergeProjectWideWarningProperties(
                    first.ProjectWideWarningProperties, 
                    second.ProjectWideWarningProperties);

                // Merge Package Specific Warning Properties
                var mergedPackageSpecificWarnings = MergePackageSpecificWarningProperties(
                    first.PackageSpecificWarningProperties,
                    second.PackageSpecificWarningProperties);

                // Ignore the project frameworks as the final collection will contain the parent project frameworks

                result = new WarningPropertiesCollection(
                    mergedProjectWideWarningProperties, 
                    mergedPackageSpecificWarnings,
                    projectFrameworks: null);
            }

            return result;
        }

        private static WarningProperties MergeProjectWideWarningProperties(WarningProperties first, 
            WarningProperties second)
        {
            WarningProperties result = null;

            if (TryMergeNullObjects(first, second, out object merged))
            {
                result = merged as WarningProperties;
            }
            else
            {
                // Merge WarningsAsErrors Sets.
                var mergedWarningsAsErrors = new HashSet<NuGetLogCode>();
                mergedWarningsAsErrors.UnionWith(first.WarningsAsErrors);
                mergedWarningsAsErrors.UnionWith(second.WarningsAsErrors);

                // Merge NoWarn Sets.
                var mergedNoWarn = new HashSet<NuGetLogCode>();
                mergedNoWarn.UnionWith(first.NoWarn);
                mergedNoWarn.UnionWith(second.NoWarn);

                // Merge AllWarningsAsErrors. If one project treats all warnigs as errors then the chain will too.
                var mergedAllWarningsAsErrors = first.AllWarningsAsErrors || second.AllWarningsAsErrors;

                result = new WarningProperties(mergedWarningsAsErrors, 
                    mergedNoWarn, 
                    mergedAllWarningsAsErrors);
            }

            return result;
        }

        private static PackageSpecificWarningProperties MergePackageSpecificWarningProperties(PackageSpecificWarningProperties first,
            PackageSpecificWarningProperties second)
        {
            PackageSpecificWarningProperties result = null;

            if (TryMergeNullObjects(first, second, out object merged))
            {
                result = merged as PackageSpecificWarningProperties;
            }
            else
            {
                result = new PackageSpecificWarningProperties();
                if (first.Properties != null)
                {
                    foreach (var code in first.Properties.Keys)
                    {
                        foreach (var libraryId in first.Properties[code].Keys)
                        {
                            result.AddRange(code, libraryId, first.Properties[code][libraryId]);
                        }
                    }
                }

                if (second.Properties != null)
                {
                    foreach (var code in second.Properties.Keys)
                    {
                        foreach (var libraryId in second.Properties[code].Keys)
                        {
                            result.AddRange(code, libraryId, second.Properties[code][libraryId]);
                        }
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Try to merge 2 objects if one or both of them are null.
        /// </summary>
        /// <param name="first">First Object to be merged.</param>
        /// <param name="second">First Object to be merged.</param>
        /// <param name="merged">Out Merged Object.</param>
        /// <returns>Returns true if atleast one of the objects was Null. 
        /// If none of them is null then the returns false, indicating that the merge failed.</returns>
        private static bool TryMergeNullObjects(object first, object second, out object merged)
        {
            merged = null;
            var result = false;

            if (first == null && second == null)
            {
                merged = null;
                result = true;
            }
            else if (first == null)
            {
                merged = second;
                result = true;
            }
            else if (second == null)
            {
                merged = first;
                result = true;
            }

            return result;
        }

        private static bool IsProject(LibraryDependencyTarget type)
        {
            if (type == LibraryDependencyTarget.ExternalProject ||
                type == LibraryDependencyTarget.Project)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// A simple node class to hold the outgoing dependency edge during the graph walk.
        /// </summary>
        private class DependencyNode : IEquatable<DependencyNode>
        {
            // ID of the Node 
            public string Id { get; }

            // bool to indicate if the node is a project node
            // if false then the node is a package
            public bool IsProject { get; }

            // WarningPropertiesCollection of the path taken to the Node
            public WarningPropertiesCollection WarningPropertiesCollection { get; }

            public DependencyNode(string id, bool isProject, WarningPropertiesCollection warningPropertiesCollection)
            {
                Id = id ?? throw new ArgumentNullException(nameof(id));
                WarningPropertiesCollection = warningPropertiesCollection ?? throw new ArgumentNullException(nameof(warningPropertiesCollection));
                IsProject = isProject;
            }

            public DependencyNode(string id, bool isProject)
            {
                Id = id ?? throw new ArgumentNullException(nameof(id));
                IsProject = isProject;
            }

            public override int GetHashCode()
            {
                var hashCode = new HashCodeCombiner();

                hashCode.AddStringIgnoreCase(Id);
                hashCode.AddObject(IsProject);

                return hashCode.CombinedHash;
            }

            public override bool Equals(object obj)
            {
                return Equals(obj as DependencyNode);
            }

            public bool Equals(DependencyNode other)
            {
                if (other == null)
                {
                    return false;
                }

                if (ReferenceEquals(this, other))
                {
                    return true;
                }

                return string.Equals(Id, other.Id, StringComparison.OrdinalIgnoreCase) &&
                    IsProject == other.IsProject &&
                    WarningPropertiesCollection.Equals(other.WarningPropertiesCollection);
            }

            public override string ToString()
            {
                return $"{(IsProject ? "Project" : "Package")}/{Id}";
            }
        }
    }
}
